import eidb from"../eidb.js";import base from"./base.js";import utils from"./utils.js";import wcrypto from"./wcrypto.js";import idb from"./idb.js";import idbx from"./idbx.js";import cruds from"./idbxs/cruds.js";import op_hists from"./idbxs/op-hists.js";import ftss from"./idbxs/ftss.js";const log=console.log,logw=console.warn,loge=console.error,new_lock=base.new_lock;var GLOBAL_DEFAULT_META={Store:"_global",Etde_Skey:null,Etde_Skey_Iv:null,Etdr_Recovery:null,Etdr_Recovery_Iv:null};class idbxs{SUB_NAMESPACES;static cruds;static op_hists;static ftss;CONSTANTS;static ITERATIONS=1e5;PROPERTIES;static Ekey=null;static Akeypair=null;static Skey=null;static Rkey=null;METHODS;static async open_av(t,e){var a=Object.keys(e);for(let t of a)null!=e[t]._secure&&(delete e[t]._secure,e["#"+t]={...e[t]},delete e[t]);return await idbx.open_av(t,e)}static async value_to_svalue(t){var e;return e=t instanceof Object&&!(t instanceof Date)?utils.obj_to_json(t):t instanceof Date?t.toISOString():t.toString(),(await wcrypto.encrypt_aes_fiv(e,idbxs.Skey))[0]}static async array_to_sarray(t){var e=[];for(let a of t)e.push(await thisclass.value_to_svalue(a));return e}static async obj_to_sobj(t,e){if(null==idbxs.Skey)return void loge("[EI] idbxs.obj_to_sobj: Static key not set");var a=Object.keys(idbx.Indices[t]);a=a.filter((t=>"id"!=t));let s=[];if(null!=e.id)var r={id:e.id};else r={};for(let t of a){if(t.indexOf(",")>=0){let a=t.split(",");for(let t of a)s.push({Path:t,Value:utils.prop_get(e,t)})}else s.push({Path:t,Value:utils.prop_get(e,t)});for(let t=0;t<s.length;t++){let e;e=s[t].Value instanceof Object&&!(s[t].Value instanceof Date)?utils.obj_to_json(s[t].Value):s[t].Value instanceof Date?s[t].Value.toISOString():s[t].Value.toString();let a=await wcrypto.encrypt_aes_fiv(e,idbxs.Skey);s[t].Svalue=a[0]}}for(let t of s){let e=t.Path,a=t.Svalue;r=utils.prop_set(r,e,a)}var i=utils.obj_to_json(e),o=await wcrypto.encrypt_aes_fiv(i,idbxs.Skey);return r.Etds_Obj=o[0],r}static async obj_to_sobj_arb(t){var e={};for(let a in t){let s;s=t[a]instanceof Object&&!(t[a]instanceof Date)?utils.obj_to_json(t[a]):t[a]instanceof Date?t[a].toISOString():t[a].toString(),e[a]=(await wcrypto.encrypt_aes_fiv(s,idbxs.Skey))[0]}return e}static async#t(t){if(null==t)return null;if(!(t instanceof Object))return(await wcrypto.encrypt_aes_fiv(t,idbxs.Skey))[0];if(t instanceof Date)return(await wcrypto.encrypt_aes_fiv(t.toISOString(),idbxs.Skey))[0];for(let e in t)t[e]=await idbxs.#t(t[e]);return t}static async obj_to_sobj_arb_rec(t){var e=JSON.parse(JSON.stringify(t));return await idbxs.#t(e)}static set_ea_keys(t,e){idbxs.Ekey=t,idbxs.Akeypair=e}static set_static_key(t){idbxs.Skey=t}static async ensure_global_meta(t){null==await idbxs.load_global_meta(t)&&await t.add(GLOBAL_DEFAULT_META)}static async load_global_meta(t){var e=t;if(null==t){var a=await eidb.reopen();t=a.transaction("_meta",eidb.RO).store1()}var s=await t.index("Store").get(eidb.value_is("_global"));return null==e&&a.close(),s}static async update_global_meta(t,e){var a=t;if(null==t){var s=await eidb.reopen();t=s.transaction("_meta",eidb.RW).store1()}var r=await idbxs.load_global_meta(t);r={...r,...e},await t.put(r),null==a&&s.close()}static async save_static_key(t,e=!1){if(null!=idbxs.Ekey&&null!=idbxs.Akeypair){var a=await wcrypto.export_key_hex(t),s=await wcrypto.encrypt_aes(a,idbxs.Ekey),[r,i]=s,o=await eidb.reopen(),_=o.transaction("_meta",eidb.RW).store1(),l=await _.index("Store").get(eidb.value_is("_global"));if(null==l&&(idbxs.ensure_global_meta(_),l=await _.index("Store").get(eidb.value_is("_global"))),null!=l.Etde_Skey&&0==e)return logw("[EI] idbxs.set_static_key: Static key exists, no enforcing"),void o.close();l.Etde_Skey=r,l.Etde_Skey_Iv=i,_.put(l),o.close()}else loge("[EI] idbxs.set_static_key: Encryption key and auth key pair must exist first, call set_ea_keys")}static async load_static_key(){if(null!=idbxs.Ekey&&null!=idbxs.Akeypair){var t=await eidb.reopen(),e=t.transaction("_meta",eidb.RW).store1(),a=await e.index("Store").get(eidb.value_is("_global"));if(null==a)return logw("[EI] idbxs.get_static_key: Global metadata not set"),await idbxs.ensure_global_meta(e),void t.close();if(null==a.Etde_Skey)return logw("[EI] idbxs.get_static_key: No static key in global metadata"),void t.close();var s=a.Etde_Skey,r=a.Etde_Skey_Iv,i=await wcrypto.decrypt_aes(s,r,idbxs.Ekey),o=await wcrypto.import_key_aes_raw(i);return t.close(),o}loge("[EI] idbxs.get_static_key: Encryption key and auth key pair must exist first, call set_ea_keys")}static async prepare_keys(t,e){var a=eidb.slocal.get("Ekey_Hex"),s=eidb.slocal.get("Akeypriv_Jwk"),r=eidb.slocal.get("Akeypub_Jwk"),i=!1;if(null!=a&&null!=s&&null!=r){var o=await wcrypto.import_key_aes_raw(a),_={privateKey:l=await wcrypto.import_key_ec_jwk(s),publicKey:c=await wcrypto.import_key_ec_jwk(r)};idbxs.set_ea_keys(o,_);try{log("[EI] Trying stored keys..."),i=null!=(n=await idbxs.load_static_key())}catch(t){}}if(!i){var[o,_]=await idbxs.get_key_chain(t,e);idbxs.set_ea_keys(o,_);var l=_.privateKey,c=_.publicKey;log("[EI] Trying keys from username and password...");var n=await idbxs.load_static_key()}if(null==n){let e;logw("[EI] idbxs.prepare_keys: No static key, creating one..."),n=await idbxs.get_new_static_key(t),await idbxs.save_static_key(n,e=!0)}idbxs.set_static_key(n),eidb.slocal.set("Ekey_Hex",await wcrypto.export_key_hex(o)),eidb.slocal.set("Akeypriv_Jwk",await wcrypto.export_key_jwk(l)),eidb.slocal.set("Akeypub_Jwk",await wcrypto.export_key_jwk(c))}static clear_keys(){eidb.slocal.clear("Ekey_Hex"),eidb.slocal.clear("Akeypriv_Jwk"),eidb.slocal.clear("Akeypub_Jwk")}static async set_user_and_pw(t,e){var a=await idbxs.load_static_key();if(null==a)return new Error("failed-to-load-static-key");idbxs.set_static_key(a);var[s,r]=await idbxs.get_key_chain(t,e);let i;idbxs.set_ea_keys(s,r),await idbxs.save_static_key(a,i=!0)}static async get_key_chain(t,e){t=t.trim(),e=e.trim(),log(`[EI] Creating key chain, ${idbxs.ITERATIONS} iterations`);var a=performance.now(),s=await wcrypto.digest_sha256(t),[r,i]=await wcrypto.password2keys(e,s,idbxs.ITERATIONS),o=performance.now();return log(`[EI] Key chain made in ${(o-a)/1e3} seconds`),[r,i]}static async get_new_static_key(t){t=t.trim();var e=await wcrypto.digest_sha256(t);return await wcrypto.make_static_key(e,1e3)}static async gen_recovery_info(t,e){var a=await wcrypto.generate_key_aes(),s=await wcrypto.export_key_hex(t),r=await wcrypto.export_key_jwk(e.privateKey),i=`${s}::${wcrypto.base64url_to_hex(r.d)}::${wcrypto.base64url_to_hex(r.x)}::${wcrypto.base64url_to_hex(r.y)}`,[o,_]=await wcrypto.encrypt_aes(i,a);return{Ciphertext:o,Iv:_,Recovery_Key:a}}static async save_recovery_info(t,e){var a=await eidb.reopen(),s=a.transaction("_meta",eidb.RW).store1(),r={Etdr_Recovery:t,Etdr_Recovery_Iv:e};await idbxs.update_global_meta(s,r),a.close()}static async recover_key_chain(t,e,a){var s=await wcrypto.decrypt_aes(t,e,a);if(null==s)return null;var[r,i,o,_]=s.split("::"),l=await wcrypto.import_key_aes_raw(r),c=await wcrypto.generate_keys_ec_sv(),n=await wcrypto.export_key_jwk(c.privateKey),y=await wcrypto.export_key_jwk(c.publicKey);n.d=wcrypto.hex_to_base64url(i),n.x=wcrypto.hex_to_base64url(o),n.y=wcrypto.hex_to_base64url(_),y.x=wcrypto.hex_to_base64url(o),y.y=wcrypto.hex_to_base64url(_);var d={};return d.privateKey=await wcrypto.import_key_ec_jwk(n),d.publicKey=await wcrypto.import_key_ec_jwk(y),[l,d]}static async recover_and_set_keys(t){if(t instanceof CryptoKey){var e=await eidb.reopen(),a=e.transaction("_meta",eidb.RO).store1(),s=await idbxs.load_global_meta(a);if(null==s)return loge("[EI] idbxs.recover_and_set_keys: Bad global metadata:",s),void e.close();var r=s.Etdr_Recovery,i=s.Etdr_Recovery_Iv;if(null==r||null==i)return loge("[EI] idbxs.recovery_and_set_keys: No or bad recovery data in global metadata"),void e.close();var[o,_]=await idbxs.recover_key_chain(r,i,t);if(!(null!=o&&null!=_&&o instanceof CryptoKey&&_.privateKey instanceof CryptoKey&&_.publicKey instanceof CryptoKey))return loge("[EI] idbxs.recovery_and_set_keys: Failed to recover keys, found:",o,_),void e.close();var l=s.Etde_Skey,c=s.Etde_Skey_Iv,n=await wcrypto.decrypt_aes(l,c,o);if(null==n)return loge("[EI] idbxs.recovery_and_set_keys: Failed to decrypt for static key"),void e.close();var y=await wcrypto.import_key_aes_raw(n);return idbxs.set_ea_keys(o,_),idbxs.set_static_key(y),e.close(),[o,_]}loge("[EI] idbxs.recover_and_set_keys: First param is not CryptoKey")}static get_micro_dict(){var t=["a","e","i","o","u","y"],e=["b","c","d","f","g","h","j","k","l","m","n","p","q","r","s","t","v","w","x","z"],a=[],s=[];for(let s of e)for(let e of t)a.push(s+e);for(let a of t)for(let t of e)s.push(a+t);var r=[],i=a.length-1;for(let t=0;t<120;t++)t%8==0?r.push(a[t]):t%8==1?r.push(s[t]):t%8==2?r.push(a[t]+a[i-t]):t%8==3?r.push(a[t]+s[t]):t%8==4?r.push(s[t]+a[t]):t%8==5?r.push(s[t]+s[i-t]):t%8==6?r.push(a[t]+s[t]+s[i-t]):t%8==7&&r.push(s[t]+a[t]+a[i-t]);r=Array.from(new Set(r)).sort();var o=[];for(let t of r)o.push(t),o.push(t.split("").reverse().join(""));o=Array.from(new Set(o)).sort();var _=[...o],l=256-o.length;for(let t=0;t<l;t++){let e=Math.floor(o.length/l*t);_.push(o[e]+o[e+1])}return _=Array.from(new Set(_)).sort()}static#e(t,e){for(let a=0;a<e;a++){let e=[...t.matchAll(/[\s]+/g)].map((t=>t.index)),a=e[Math.floor(Math.random()*e.length)],s=t.split("");s[a]=".",t=s.join("")}return t}static#a(t,e){for(let a=0;a<e;a++){let e=[...t.matchAll(/[\s]+/g)].map((t=>t.index)),a=e[Math.floor(Math.random()*e.length)],s=t.split("");s[a]=",",t=s.join("")}return t}static#s(t){var e=(t=t.replaceAll(",",", ")).split(".");for(let t=0;t<e.length;t++)e[t]=e[t].charAt(0).toUpperCase()+e[t].substring(1);return t=e.join(". "),t+="."}static async key_to_text(t){var e=await wcrypto.export_key_hex(t),a=idbxs.get_micro_dict(),s=wcrypto.hex_to_bytes(e),r=[];for(let t=0;t<s.byteLength;t++)r.push(a[s[t]]);var i=r.join(" ");return i=idbxs.#e(i,4),i=idbxs.#a(i,8),i=idbxs.#s(i)}static async text_to_key(t){var e=(t=(t=(t=t.toLowerCase().replaceAll(/[^a-z]+/g," ")).trim()).replaceAll(/[\s]{2,}/g," ")).split(" "),a=idbxs.get_micro_dict(),s=new Uint8Array(32);for(let t of e)if(-1==a.indexOf(t))return void loge("[EI] idbxs.text_to_key: Invalid word:",t);for(let t=0;t<e.length;t++){let r=e[t],i=a.indexOf(r);s[t]=i}var r=wcrypto.bytes_to_hex(s);return await wcrypto.import_key_aes_raw(r)}static init(){idbxs.cruds=cruds,idbxs.op_hists=op_hists,idbxs.ftss=ftss,idbxs.cruds.init(),idbxs.op_hists.init(),idbxs.ftss.init()}}const thisclass=idbxs;export default thisclass;