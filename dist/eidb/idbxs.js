import eidb from"../eidb.js";import base from"./base.js";import utils from"./utils.js";import wcrypto from"./wcrypto.js";import idb from"./idb.js";import idbx from"./idbx.js";import cruds from"./idbxs/cruds.js";import op_hists from"./idbxs/op-hists.js";import ftss from"./idbxs/ftss.js";const log=console.log,logw=console.warn,loge=console.error,new_lock=base.new_lock;var GLOBAL_DEFAULT_META={Store:"_global",Etde_Skey:null,Etde_Skey_Iv:null,Etdr_Recovery:null,Etdr_Recovery_Iv:null};class idbxs{SUB_NAMESPACES;static cruds;static op_hists;static ftss;CONSTANTS;static ITERATIONS=1e5;PROPERTIES;static Ekey=null;static Akeypair=null;static Skey=null;static Rkey=null;METHODS;static async open_av(t,e){var a=Object.keys(e);for(let t of a)null!=e[t]._secure&&(delete e[t]._secure,e["#"+t]={...e[t]},delete e[t]);return await idbx.open_av(t,e)}static async value_to_svalue(t){var e;return e=t instanceof Object&&!(t instanceof Date)?utils.obj_to_json(t):t instanceof Date?t.toISOString():t.toString(),(await wcrypto.encrypt_aes_fiv(e,idbxs.Skey))[0]}static async array_to_sarray(t){var e=[];for(let a of t)e.push(await thisclass.value_to_svalue(a));return e}static async obj_to_sobj(t,e){if(null==idbxs.Skey)return void loge("[EI] idbxs.obj_to_sobj: Static key not set");var a=Object.keys(idbx.Indices[t]);a=a.filter((t=>"id"!=t));let i=[];if(null!=e.id)var s={id:e.id};else s={};for(let t of a){if(t.indexOf(",")>=0){let a=t.split(",");for(let t of a)i.push({Path:t,Value:utils.prop_get(e,t)})}else i.push({Path:t,Value:utils.prop_get(e,t)});for(let t=0;t<i.length;t++){let e;e=i[t].Value instanceof Object&&!(i[t].Value instanceof Date)?utils.obj_to_json(i[t].Value):i[t].Value instanceof Date?i[t].Value.toISOString():i[t].Value.toString();let a=await wcrypto.encrypt_aes_fiv(e,idbxs.Skey);i[t].Svalue=a[0]}}for(let t of i){let e=t.Path,a=t.Svalue;s=utils.prop_set(s,e,a)}var r=utils.obj_to_json(e),o=await wcrypto.encrypt_aes_fiv(r,idbxs.Skey);return s.Etds_Obj=o[0],s}static async obj_to_sobj_arb(t){var e={};for(let a in t){let i;i=t[a]instanceof Object&&!(t[a]instanceof Date)?utils.obj_to_json(t[a]):t[a]instanceof Date?t[a].toISOString():t[a].toString(),e[a]=(await wcrypto.encrypt_aes_fiv(i,idbxs.Skey))[0]}return e}static async#t(t){if(null==t)return null;if(!(t instanceof Object))return(await wcrypto.encrypt_aes_fiv(t,idbxs.Skey))[0];if(t instanceof Date)return(await wcrypto.encrypt_aes_fiv(t.toISOString(),idbxs.Skey))[0];for(let e in t)t[e]=await idbxs.#t(t[e]);return t}static async obj_to_sobj_arb_rec(t){var e=JSON.parse(JSON.stringify(t));return await idbxs.#t(e)}static set_ea_keys(t,e){idbxs.Ekey=t,idbxs.Akeypair=e}static set_static_key(t){idbxs.Skey=t}static async ensure_global_meta(t){null==await idbxs.load_global_meta(t)&&await t.add(GLOBAL_DEFAULT_META)}static async load_global_meta(t){var e=t;if(null==t){var a=await eidb.reopen();t=a.transaction("_meta",eidb.RO).store1()}var i=await t.index("Store").get(eidb.value_is("_global"));return null==e&&a.close(),i}static async update_global_meta(t,e){var a=t;if(null==t){var i=await eidb.reopen();t=i.transaction("_meta",eidb.RW).store1()}var s=await idbxs.load_global_meta(t);s={...s,...e},await t.put(s),null==a&&i.close()}static async save_static_key(t,e=!1){if(null!=idbxs.Ekey&&null!=idbxs.Akeypair){var a=await wcrypto.export_key_hex(t),i=await wcrypto.encrypt_aes(a,idbxs.Ekey),[s,r]=i,o=await eidb.reopen(),_=o.transaction("_meta",eidb.RW).store1(),l=await _.index("Store").get(eidb.value_is("_global"));if(null==l&&(idbxs.ensure_global_meta(_),l=await _.index("Store").get(eidb.value_is("_global"))),null!=l.Etde_Skey&&0==e)return logw("[EI] idbxs.save_static_key: Static key exists, no enforcing"),void o.close();l.Etde_Skey=s,l.Etde_Skey_Iv=r,_.put(l),o.close()}else loge("[EI] idbxs.save_static_key: Encryption key and auth key pair must exist first, call set_ea_keys")}static async load_static_key(){if(null!=idbxs.Ekey&&null!=idbxs.Akeypair){var t=await eidb.reopen(),e=t.transaction("_meta",eidb.RW).store1(),a=await e.index("Store").get(eidb.value_is("_global"));if(null==a)return logw("[EI] idbxs.load_static_key: Global metadata not set"),await idbxs.ensure_global_meta(e),void t.close();if(null==a.Etde_Skey)return logw("[EI] idbxs.load_static_key: No static key in global metadata"),void t.close();var i=a.Etde_Skey,s=a.Etde_Skey_Iv,r=await wcrypto.decrypt_aes(i,s,idbxs.Ekey),o=await wcrypto.import_key_aes_raw(r);return t.close(),o}loge("[EI] idbxs.load_static_key: Encryption key and auth key pair must exist first, call set_ea_keys")}static async save_data_iv(t){await eidb.update_one("_meta",{Store:"_global"},{Etds_Data_Iv:t})}static async load_data_iv(){var t=await eidb.find_one("_meta",{Store:"_global"});return null==t?null:t.Etds_Data_Iv}static async prepare_keys(t,e){var a=eidb.slocal.get("Ekey_Hex"),i=eidb.slocal.get("Akeypriv_Jwk"),s=eidb.slocal.get("Akeypub_Jwk"),r=!1;if(null!=a&&null!=i&&null!=s){var o=await wcrypto.import_key_aes_raw(a),_={privateKey:l=await wcrypto.import_key_ec_jwk(i),publicKey:c=await wcrypto.import_key_ec_jwk(s)};idbxs.set_ea_keys(o,_);try{log("[EI] Trying stored keys..."),r=null!=(n=await idbxs.load_static_key())}catch(t){}}if(!r){var[o,_]=await idbxs.get_key_chain(t,e);idbxs.set_ea_keys(o,_);var l=_.privateKey,c=_.publicKey;log("[EI] Trying keys from username and password...");var n=await idbxs.load_static_key()}var y=null;if(null==n){let e;logw("[EI] idbxs.prepare_keys: No static key, creating one..."),n=await idbxs.get_new_static_key(t),y=await wcrypto.bytes_to_hex(await wcrypto.random_iv()),await idbxs.save_static_key(n,e=!0),await idbxs.save_data_iv(y)}idbxs.set_static_key(n),thisclass.FIXED_IV=null!=y?y:await thisclass.load_data_iv(),eidb.slocal.set("Ekey_Hex",await wcrypto.export_key_hex(o)),eidb.slocal.set("Akeypriv_Jwk",await wcrypto.export_key_jwk(l)),eidb.slocal.set("Akeypub_Jwk",await wcrypto.export_key_jwk(c))}static clear_keys(){eidb.slocal.clear("Ekey_Hex"),eidb.slocal.clear("Akeypriv_Jwk"),eidb.slocal.clear("Akeypub_Jwk")}static async set_user_and_pw(t,e){var a=await idbxs.load_static_key();if(null==a)return new Error("failed-to-load-static-key");idbxs.set_static_key(a);var[i,s]=await idbxs.get_key_chain(t,e);let r;idbxs.set_ea_keys(i,s),await idbxs.save_static_key(a,r=!0)}static async get_key_chain(t,e){t=t.trim(),e=e.trim(),log(`[EI] Creating key chain, ${idbxs.ITERATIONS} iterations`);var a=performance.now(),i=await wcrypto.digest_sha256(t),[s,r]=await wcrypto.password2keys(e,i,idbxs.ITERATIONS),o=performance.now();return log(`[EI] Key chain made in ${(o-a)/1e3} seconds`),[s,r]}static async get_new_static_key(t){t=t.trim();var e=await wcrypto.digest_sha256(t);return await wcrypto.make_static_key(e,1e3)}static async gen_recovery_info(t,e){var a=await wcrypto.generate_key_aes(),i=await wcrypto.export_key_hex(t),s=await wcrypto.export_key_jwk(e.privateKey),r=`${i}::${wcrypto.base64url_to_hex(s.d)}::${wcrypto.base64url_to_hex(s.x)}::${wcrypto.base64url_to_hex(s.y)}`,[o,_]=await wcrypto.encrypt_aes(r,a);return{Ciphertext:o,Iv:_,Recovery_Key:a}}static async save_recovery_info(t,e){var a=await eidb.reopen(),i=a.transaction("_meta",eidb.RW).store1(),s={Etdr_Recovery:t,Etdr_Recovery_Iv:e};await idbxs.update_global_meta(i,s),a.close()}static async recover_key_chain(t,e,a){var i=await wcrypto.decrypt_aes(t,e,a);if(null==i)return null;var[s,r,o,_]=i.split("::"),l=await wcrypto.import_key_aes_raw(s),c=await wcrypto.generate_keys_ec_sv(),n=await wcrypto.export_key_jwk(c.privateKey),y=await wcrypto.export_key_jwk(c.publicKey);n.d=wcrypto.hex_to_base64url(r),n.x=wcrypto.hex_to_base64url(o),n.y=wcrypto.hex_to_base64url(_),y.x=wcrypto.hex_to_base64url(o),y.y=wcrypto.hex_to_base64url(_);var d={};return d.privateKey=await wcrypto.import_key_ec_jwk(n),d.publicKey=await wcrypto.import_key_ec_jwk(y),[l,d]}static async recover_and_set_keys(t){if(t instanceof CryptoKey){var e=await eidb.reopen(),a=e.transaction("_meta",eidb.RO).store1(),i=await idbxs.load_global_meta(a);if(null==i)return loge("[EI] idbxs.recover_and_set_keys: Bad global metadata:",i),void e.close();var s=i.Etdr_Recovery,r=i.Etdr_Recovery_Iv;if(null==s||null==r)return loge("[EI] idbxs.recovery_and_set_keys: No or bad recovery data in global metadata"),void e.close();var[o,_]=await idbxs.recover_key_chain(s,r,t);if(!(null!=o&&null!=_&&o instanceof CryptoKey&&_.privateKey instanceof CryptoKey&&_.publicKey instanceof CryptoKey))return loge("[EI] idbxs.recovery_and_set_keys: Failed to recover keys, found:",o,_),void e.close();var l=i.Etde_Skey,c=i.Etde_Skey_Iv,n=await wcrypto.decrypt_aes(l,c,o);if(null==n)return loge("[EI] idbxs.recovery_and_set_keys: Failed to decrypt for static key"),void e.close();var y=await wcrypto.import_key_aes_raw(n);return idbxs.set_ea_keys(o,_),idbxs.set_static_key(y),e.close(),[o,_]}loge("[EI] idbxs.recover_and_set_keys: First param is not CryptoKey")}static get_micro_dict(){var t=["a","e","i","o","u","y"],e=["b","c","d","f","g","h","j","k","l","m","n","p","q","r","s","t","v","w","x","z"],a=[],i=[];for(let i of e)for(let e of t)a.push(i+e);for(let a of t)for(let t of e)i.push(a+t);var s=[],r=a.length-1;for(let t=0;t<120;t++)t%8==0?s.push(a[t]):t%8==1?s.push(i[t]):t%8==2?s.push(a[t]+a[r-t]):t%8==3?s.push(a[t]+i[t]):t%8==4?s.push(i[t]+a[t]):t%8==5?s.push(i[t]+i[r-t]):t%8==6?s.push(a[t]+i[t]+i[r-t]):t%8==7&&s.push(i[t]+a[t]+a[r-t]);s=Array.from(new Set(s)).sort();var o=[];for(let t of s)o.push(t),o.push(t.split("").reverse().join(""));o=Array.from(new Set(o)).sort();var _=[...o],l=256-o.length;for(let t=0;t<l;t++){let e=Math.floor(o.length/l*t);_.push(o[e]+o[e+1])}return _=Array.from(new Set(_)).sort()}static#e(t,e){for(let a=0;a<e;a++){let e=[...t.matchAll(/[\s]+/g)].map((t=>t.index)),a=e[Math.floor(Math.random()*e.length)],i=t.split("");i[a]=".",t=i.join("")}return t}static#a(t,e){for(let a=0;a<e;a++){let e=[...t.matchAll(/[\s]+/g)].map((t=>t.index)),a=e[Math.floor(Math.random()*e.length)],i=t.split("");i[a]=",",t=i.join("")}return t}static#i(t){var e=(t=t.replaceAll(",",", ")).split(".");for(let t=0;t<e.length;t++)e[t]=e[t].charAt(0).toUpperCase()+e[t].substring(1);return t=e.join(". "),t+="."}static async key_to_text(t){var e=await wcrypto.export_key_hex(t),a=idbxs.get_micro_dict(),i=wcrypto.hex_to_bytes(e),s=[];for(let t=0;t<i.byteLength;t++)s.push(a[i[t]]);var r=s.join(" ");return r=idbxs.#e(r,4),r=idbxs.#a(r,8),r=idbxs.#i(r)}static async text_to_key(t){var e=(t=(t=(t=t.toLowerCase().replaceAll(/[^a-z]+/g," ")).trim()).replaceAll(/[\s]{2,}/g," ")).split(" "),a=idbxs.get_micro_dict(),i=new Uint8Array(32);for(let t of e)if(-1==a.indexOf(t))return void loge("[EI] idbxs.text_to_key: Invalid word:",t);for(let t=0;t<e.length;t++){let s=e[t],r=a.indexOf(s);i[t]=r}var s=wcrypto.bytes_to_hex(i);return await wcrypto.import_key_aes_raw(s)}static init(){idbxs.cruds=cruds,idbxs.op_hists=op_hists,idbxs.ftss=ftss,idbxs.cruds.init(),idbxs.op_hists.init(),idbxs.ftss.init()}}const thisclass=idbxs;export default thisclass;