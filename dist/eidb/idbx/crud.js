import eidb from"../../eidb.js";import base from"../base.js";import utils from"../utils.js";import op_hist from"./op-hist.js";import fts from"./fts.js";import ftss from"../idbxs/ftss.js";var log=console.log,logw=console.warn,loge=console.error,new_lock=base.new_lock,json2obj=JSON.parse,obj2json=JSON.stringify;class crud{static async insert_one(e,t,a=!1,n=null){var r=await eidb.reopen(),s=r.transaction(e,eidb.RW).store1(),l={...t};delete l.id;var i=await s.add(l);return i instanceof Error?(loge("[EI] crud.insert_one: Failed, error:",i),null==s&&r.close(),null):(op_hist.update_op_hist_c(s.Name,[i]),a?ftss.update_fts_c(s.Name,i,n):fts.update_fts_c(s.Name,i,t),null==s&&r.close(),i)}static async insert_many(e,t,a=!1,n=null){var r=await eidb.reopen(),s=r.transaction(e,eidb.RW).store1(),l=[],[i,o]=new_lock();if(null==t||0==t.length)return r.close(),[];for(let e of t){let a={...e};delete a.id;let n=s.self.add(a);n.onerror=e=>{loge("[EI] crud.insert_many: Failed to add object, error:",e.target.error),l.push(null),l.length==t.length&&o()},n.onsuccess=e=>{l.push(e.target.result),l.length==t.length&&o()}}await i;for(let e=0;e<l.length;e++)a?ftss.update_fts_c(s.Name,l[e],n[e]):fts.update_fts_c(s.Name,l[e],t[e]);return r.close(),l}static async get_1stcond_obj(e,t){var a=Object.keys(t),n=e.index(a[0]);if(n instanceof Error)return loge("[EI] crud.get_1stcond_obj: Failed to get index, add this index to schema:",e.Name,"/",a[0]),null;var r=t[a[0]];return await n.get(r)}static async get_1stcond_objs(e,t){var a=Object.keys(t),n=e.index(a[0]);if(n instanceof Error)return loge("[EI] crud.get_1stcond_obj: Failed to get index, add this index to schema:",e.Name,"/",a[0]),null;var r=t[a[0]];return await n.get_all(r)}static async intersect_cond(e,t){var a=Object.keys(t);if(0==a.length)return[];var n=[];for(let r of a){let a=e.index(r);if(a instanceof Error)return loge("[EI] crud.get_1stcond_obj: Failed to get index, add this index to schema:",e.Name,"/",r),null;let s=t[r],l=(await a.get_all(s)).map((e=>e.id));n.push(l)}return utils.intersect_arrs(n)}static async intersect_cond_getobjs(e,t){var a=Object.keys(t);if(0==a.length)return[];var n=[],r={};for(let s of a){let a=e.index(s);if(a instanceof Error)return loge("[EI] crud.get_1stcond_obj: Failed to get index, add this index to schema:",e.Name,"/",s),null;let l=t[s],i=(await a.get_all(l)).map((e=>(r[e.id]=e,e.id)));n.push(i)}return utils.intersect_arrs(n).map((e=>r[e]))}static async exists(e,t,a=!1){var n=await eidb.reopen(),r=n.transaction(e,eidb.RO).store1(),s=Object.keys(t);if(0==s.length)return n.close(),[];if(1==s.length){let e=await crud.get_1stcond_obj(r,t);return n.close(),null!=e}var l=await crud.intersect_cond(r,t);return n.close(),l.length>0}static async count(e,t,a=!1){var n=await eidb.reopen(),r=n.transaction(e,eidb.RO).store1(),s=Object.keys(t);if(0==s.length)return n.close(),null;if(1==s.length){let e=await crud.get_1stcond_objs(r,t);return n.close(),e.length}var l=await crud.intersect_cond(r,t);return n.close(),l.length}static async count_all(e,t=!1){var a=await eidb.reopen(),n=a.transaction(e,eidb.RO).store1(),r=await n.count();return a.close(),r}static async find_one(e,t,a=!1){var n=await eidb.reopen(),r=n.transaction(e,eidb.RO).store1(),s=Object.keys(t);if(0==s.length)return n.close(),null;if(1==s.length){let e=await crud.get_1stcond_obj(r,t);return null==e?(n.close(),null):(op_hist.update_op_hist_r(r.Name,[e.id]),n.close(),e)}var l=await crud.intersect_cond(r,t);if(0==l.length)return n.close(),null;var i=await r.get(eidb.value_is(l[0]));return op_hist.update_op_hist_r(r.Name,l),n.close(),i}static async find_many(e,t,a=Number.MAX_SAFE_INTEGER,n=!1){var r=await eidb.reopen(),s=r.transaction(e,eidb.RO).store1(),l=Object.keys(t);if(0==l.length)return r.close(),null;if(1==l.length){let e=await crud.get_1stcond_objs(s,t);return r.close(),e}var i=await crud.intersect_cond(s,t);if(null==i||0==i.length)return r.close(),[];var o=[],[u,c]=new_lock();for(let e of i){let t=s.self.get(eidb.value_is(e).self);t.onerror=e=>{o.push(null),o.length==i.length&&c(),o.length>=a&&c()},t.onsuccess=e=>{o.push(e.target.result),o.length==i.length&&c(),o.length>=a&&c()}}return await u,r.close(),o}static async find_all(e,t=!1){var a=await eidb.reopen(),n=a.transaction(e,eidb.RO).store1(),r=await n.get_all();return a.close(),r}static get_proppath_value(e,t){var a=t.split("."),n=e;for(let e of a){if(null==n[e])return null;n=n[e]}return n}static obj_matches_cond(e,t){for(let a in t){let n=t[a],r=crud.get_proppath_value(e,a);if(null==r)return!1;if(-1==obj2json(r).indexOf(n))return!1}return!0}static async filter(e,t,a=Number.MAX_SAFE_INTEGER,n=!1){var r=await eidb.reopen(),s=r.transaction(e,eidb.RO).store1(),l=[];return await s.open_cursor(eidb.range_gte(0),"next",(e=>{var n=e.value;if(crud.obj_matches_cond(n,t)&&l.push(n),l.length>=a)return eidb._stop})),r.close(),l}static async update_one(e,t,a,n=!1,r=null){var s=await eidb.reopen(),l=s.transaction(e,eidb.RW).store1(),i=Object.keys(t);if(0==i.length)return s.close(),null;let o={...a};if(delete o.id,1==i.length){let e=await crud.get_1stcond_obj(l,t);return null==e?(s.close(),null):(e={...e,...o},l.put(e),op_hist.update_op_hist_u(l.Name,[e.id]),n?ftss.update_fts_u(l.Name,e.id,r):fts.update_fts_u(l.Name,e.id,e),s.close(),e)}var u=await crud.intersect_cond(l,t);if(null==u||0==u.length)return s.close(),null;var c=await l.get(eidb.value_is(u[0]));return null==c?(s.close(),null):(c={...c,...o},await l.put(c),op_hist.update_op_hist_u(l.Name,[c.id]),n?ftss.update_fts_u(l.Name,c.id,c):fts.update_fts_u(l.Name,c.id,c),s.close(),c)}static async update_many(e,t,a,n=Number.MAX_SAFE_INTEGER,r=!1){var s=await eidb.reopen(),l=s.transaction(e,eidb.RW).store1(),i=Object.keys(t);if(0==i.length)return s.close(),null;let o={...a};if(delete o.id,1==i.length){if(null==(u=await crud.get_1stcond_objs(l,t)))return s.close(),null;if(0==u.length)return s.close(),[]}else{var u;if(null==(u=await crud.intersect_cond_getobjs(l,t)))return s.close(),null;if(0==u.length)return s.close(),[]}let c=[],[d,_]=new_lock();for(let e of u){let t={...e,...o},a=l.self.put(t);a.onerror=t=>{loge("[EI] crud.update_many: Failed to update object:",e),c.push(null),c.length==u.length&&_(),c.length>=n&&_()},a.onsuccess=e=>{c.push({...t,id:e.target.result}),c.length==u.length&&_(),c.length>=n&&_()}}await d;for(let e=0;e<c.length;e++)r||fts.update_fts_u(l.Name,c[e].id,c[e]);return s.close(),c}static async upsert_one(e,t,a,n=!1,r=null){var s=await eidb.reopen(),l=s.transaction(e,eidb.RW).store1(),i=Object.keys(t);if(0==i.length)return s.close(),null;let o={...a};if(delete o.id,1==i.length){let e=await crud.get_1stcond_obj(l,t);if(null==e){let e=await l.add(o);return op_hist.update_op_hist_c(l.Name,[e]),n?ftss.update_fts_c(l.Name,e,r):fts.update_fts_c(l.Name,e,a),s.close(),e}return e={...e,...o},l.put(e),op_hist.update_op_hist_u(l.Name,[e.id]),n?ftss.update_fts_u(l.Name,e.id,r):fts.update_fts_u(l.Name,e.id,e),s.close(),e.id}var u=await crud.intersect_cond(l,t);if(null==u||0==u.length)return s.close(),null;var c=await l.get(eidb.value_is(u[0]));if(null==c){let e=await l.add(o);return op_hist.update_op_hist_c(l.Name,[e]),n?ftss.update_fts_c(l.Name,e,r):fts.update_fts_c(l.Name,e,a),s.close(),e}return c={...c,...o},l.put(c),op_hist.update_op_hist_u(l.Name,[c.id]),n?ftss.update_fts_u(l.Name,c.id,r):fts.update_fts_u(l.Name,c.id,c),s.close(),c.id}static async remove_one(e,t,a=!1,n=null){var r=await eidb.reopen(),s=r.transaction(e,eidb.RW).store1(),l=Object.keys(t);if(0==l.length)return r.close(),null;if(1==l.length){let e=await crud.get_1stcond_obj(s,t);if(null==e)return r.close(),null;let l=await s.delete(eidb.value_is(e.id));return op_hist.update_op_hist_d(s.Name,[e.id]),a?ftss.update_fts_d(s.Name,e.id,n):fts.update_fts_d(s.Name,e.id,e),r.close(),l}var i=await crud.intersect_cond_getobjs(s,t),o=i.map((e=>e.id));if(null==o||0==o.length)return r.close(),null;var u=await s.delete(eidb.value_is(o[0]));return op_hist.update_op_hist_d(s.Name,[o[0]]),a?ftss.update_fts_d(s.Name,o[0],n):fts.update_fts_d(s.Name,o[0],i[0]),r.close(),u}static async remove_many(e,t,a=!1,n=null){var r=await eidb.reopen(),s=r.transaction(e,eidb.RW).store1(),l=Object.keys(t);if(0==l.length)return r.close(),null;var i=[],o=[];if(1==l.length){if(i=await crud.get_1stcond_objs(s,t),o=i.map((e=>e.id)),null==i||0==i.length)return r.close(),null}else if(i=await crud.intersect_cond_getobjs(s,t),null==(o=i.map((e=>e.id)))||0==o.length)return r.close(),null;var[u,c]=new_lock(),d=0;for(let e of o){let t=s.self.delete(eidb.value_is(e).self);t.onerror=e=>{++d==o.length&&c()},t.onsuccess=e=>{++d==o.length&&c()}}await u;for(let e=0;e<o.length;e++)a?ftss.update_fts_d(s.Name,o[e],n[e]):fts.update_fts_d(s.Name,o[e],i[e]);return r.close(),null}static async remove_all(e){var t=await eidb.reopen(),a=t.transaction(e,eidb.RW).store1(),[n,r]=new_lock(),s=a.self.delete(eidb.range_gte(0).self);return s.onerror=e=>{loge("[EI] crud.remove_all: Failed to delete, event:",e),r()},s.onsuccess=e=>{r()},await n,t.close(),null}static init(){}}export default crud;