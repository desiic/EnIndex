import base from"../base.js";import crud from"../idbx/crud.js";import fts from"../idbx/fts.js";import idbxs from"../idbxs.js";import wcrypto from"../wcrypto.js";import utils from"../utils.js";const log=console.log,logw=console.warn,loge=console.error,new_lock=base.new_lock;class cruds{static async insert_one(t,e){if(null!=idbxs.Skey){t="#"+t;var s=await idbxs.obj_to_sobj(t,e);return await crud.insert_one(t,s,_secure,e)}loge("cruds.insert_one: Static key not set")}static async insert_many(t,e){if(null!=idbxs.Skey){t="#"+t;var s=[];for(let a of e)s.push(await idbxs.obj_to_sobj(t,a));return await crud.insert_many(t,s,_secure,e)}loge("cruds.insert_many: Static key not set")}static async get_1stcond_obj(t,e){}static async get_1stcond_objs(t,e){}static async intersect_cond(t,e){}static async intersect_cond_getobjs(t,e){}static async exists(t,e){if(null!=idbxs.Skey){t="#"+t;var s={};for(let t in e)s[t]=await idbxs.value_to_svalue(e[t]);return await crud.exists(t,s,_secure)}loge("cruds.exists: Static key not set")}static async count(t,e){if(null!=idbxs.Skey){t="#"+t;var s={};for(let t in e)s[t]=await idbxs.value_to_svalue(e[t]);return await crud.count(t,s,_secure)}loge("cruds.count: Static key not set")}static async count_all(t){if(null!=idbxs.Skey)return t="#"+t,await crud.count_all(t,_secure);loge("cruds.count_all: Static key not set")}static async find_one(t,e){if(null!=idbxs.Skey){t="#"+t;var s={};for(let t in e)s[t]=await idbxs.value_to_svalue(e[t]);var a=await crud.find_one(t,s,_secure);if(null==a)return null;var i=await wcrypto.decrypt_aes_fiv(a.Etds_Obj,idbxs.Skey),r=utils.json_to_obj_bd(i);return r.id=a.id,r}loge("cruds.find_one: Static key not set")}static async find_many(t,e,s=Number.MAX_SAFE_INTEGER){if(null!=idbxs.Skey){t="#"+t;var a={};for(let t in e)a[t]=await idbxs.value_to_svalue(e[t]);var i=await crud.find_many(t,a,s,_secure),r=[];for(let t of i){var o=await wcrypto.decrypt_aes_fiv(t.Etds_Obj,idbxs.Skey),_=utils.json_to_obj_bd(o);_.id=t.id,r.push(_)}return r}loge("cruds.find_many: Static key not set")}static async find_all(t){if(null!=idbxs.Skey){t="#"+t;var e=await crud.find_all(t,_secure),s=[];for(let t of e){var a=await wcrypto.decrypt_aes_fiv(t.Etds_Obj,idbxs.Skey);if(null!=a){var i=utils.json_to_obj_bd(a);i.id=t.id,s.push(i)}}return s}loge("cruds.find_all: Static key not set")}static get_proppath_value(t,e){}static obj_matches_cond(t,e){}static async filter(t,e,s=Number.MAX_SAFE_INTEGER){if(null!=idbxs.Skey){t="#"+t;var a={};for(let t in e)a[t]=await idbxs.value_to_svalue(e[t]);var i=await crud.filter(t,a,s,_secure),r=[];for(let t of i){var o=await wcrypto.decrypt_aes_fiv(t.Etds_Obj,idbxs.Skey),_=utils.json_to_obj_bd(o);_.id=t.id,r.push(_)}return r}loge("cruds.filter: Static key not set")}static async update_one(t,e,s){if(null!=idbxs.Skey){t="#"+t;var a=await idbxs.obj_to_sobj_full(s),i={};for(let t in e)i[t]=await idbxs.value_to_svalue(e[t]);var r=await crud.find_one(t,i,_secure),o=await wcrypto.decrypt_aes_fiv(r.Etds_Obj,idbxs.Skey),_=utils.json_to_obj_bd(o);_={..._,...s},o=utils.obj_to_json(_),a.Etds_Obj=(await wcrypto.encrypt_aes_fiv(o,idbxs.Skey))[0];var n=await crud.update_one(t,i,a,_secure,_);o=await wcrypto.decrypt_aes_fiv(n.Etds_Obj,idbxs.Skey);return(_=utils.json_to_obj_bd(o)).id=n.id,_}loge("cruds.update_one: Static key not set")}static async update_many(t,e,s,a=Number.MAX_SAFE_INTEGER){if(null!=idbxs.Skey){t="#"+t;var i=utils.deepcopy(s);delete i.id,s=i;var r=await idbxs.obj_to_sobj_full(s),o=[],_={};for(let t in e)_[t]=await idbxs.value_to_svalue(e[t]);var n=await crud.find_many(t,_,_secure),d=[];for(let t of n){let e=await wcrypto.decrypt_aes_fiv(t.Etds_Obj,idbxs.Skey),a=utils.json_to_obj_bd(e);a={...a,...s,id:t.id},e=utils.obj_to_json(a),d.push(a);let i=utils.deepcopy(r);i.Etds_Obj=(await wcrypto.encrypt_aes_fiv(e,idbxs.Skey))[0],o.push(i)}var u=await eidb.reopen(),c=u.transaction(t,RW).store1(),l=0,b=[],[y,f]=new_lock();for(let e=0;e<n.length;e++){let s,a={...n[e],...o[e]};c.put(a,null,s=!1,(s=>{s instanceof Error?(loge("cruds.update_many: Error:",s),b.push(null)):b.push(a),fts.update_fts_u(t,d[e].id,d[e]),++l==n.length&&f()}))}await y;var v=[];for(let t of b){let e=await wcrypto.decrypt_aes_fiv(t.Etds_Obj,idbxs.Skey),s=utils.json_to_obj_bd(e);s.id=t.id,v.push(s)}return u.close(),v}loge("cruds.update_many: Static key not set")}static async upsert_one(t,e,s){if(null!=idbxs.Skey){t="#"+t;var a=await idbxs.obj_to_sobj_full(s),i={};for(let t in e)i[t]=await idbxs.value_to_svalue(e[t]);var r=await crud.find_one(t,i,_secure),o=await wcrypto.decrypt_aes_fiv(r.Etds_Obj,idbxs.Skey),_=utils.json_to_obj_bd(o);return _={..._,...s},o=utils.obj_to_json(_),a.Etds_Obj=(await wcrypto.encrypt_aes_fiv(o,idbxs.Skey))[0],await crud.upsert_one(t,i,a,_secure,_)}loge("cruds.upsert_one: Static key not set")}static async remove_one(t,e){if(null!=idbxs.Skey){t="#"+t;var s={};for(let t in e)s[t]=await idbxs.value_to_svalue(e[t]);var a=await crud.find_one(t,s,_secure);if(null==a)return null;var i=await wcrypto.decrypt_aes_fiv(a.Etds_Obj,idbxs.Skey),r=utils.json_to_obj_bd(i);r.id=a.id,await crud.remove_one(t,s,_secure,r)}else loge("cruds.remove_one: Static key not set")}static async remove_many(t,e){if(null!=idbxs.Skey){t="#"+t;var s={};for(let t in e)s[t]=await idbxs.value_to_svalue(e[t]);var a=[],i=await crud.find_many(t,s,_secure);if(null==i||0==i.length)return null;for(let t of i){var r=await wcrypto.decrypt_aes_fiv(t.Etds_Obj,idbxs.Skey),o=utils.json_to_obj_bd(r);o.id=t.id,a.push(o)}await crud.remove_many(t,s,_secure,a)}else loge("cruds.remove_many: Static key not set")}static init(){}}export default cruds;